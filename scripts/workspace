#!/bin/bash
# Enhanced script to create, list, and switch ephemeral workspaces.

set -e # Exit immediately if a command exits with a non-zero status.

# --- Configuration ---
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/config.sh"

# --- Derived Configurations ---
DETECTORS_DIR="$SCRIPT_DIR/detectors"
PROJECT_ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
CONFIG_FILE_PATH="$PROJECT_ROOT_DIR/$WORKSPACE_CONFIGS_FILE"
WARM_SCRIPT_PATH="$SCRIPT_DIR/warm_workspaces.sh"

# --- Helper Functions ---

show_help() {
    cat << EOF
Usage: workspace [COMMAND|PROJECT_NAME|GIT_URL]

A tool for creating, managing, and switching between ephemeral development workspaces.

COMMANDS:
  warm          Manually refresh all Git-based workspaces by fetching the latest changes.
  --help        Show this help message.

MODES:
  Interactive:  workspace
                Shows a searchable menu of recent workspaces (requires fzf for the best experience).

  Direct:       workspace <n>
                Switch to the n-th most recent workspace.

                workspace <name>
                Create or switch to a local workspace named <name>.

                workspace <git_url>
                Clone a git repository and create a new workspace.
EOF
}

_link_configs() {
    local project_path="$1"
    if [ ! -d "$project_path" ]; then return; fi

    if [ ! -f "$CONFIG_FILE_PATH" ]; then
        echo "Warning: Configuration file not found at $CONFIG_FILE_PATH" >&2
        return
    fi

    echo "Linking configurations from $CONFIG_FILE_PATH..." >&2
    while IFS= read -r item || [[ -n "$item" ]]; do
        # Skip comments and empty lines
        if [[ "$item" =~ ^\s*# ]] || [ -z "$item" ]; then continue; fi

        # Skip shell-specific files, they are handled separately.
        if [[ "$item" == ".bashrc" || "$item" == ".profile" || "$item" == ".zshrc" || "$item" == ".zprofile" ]]; then continue; fi

        local source_path="$HOME/$item"
        local link_path="$project_path/$(basename "$item")"
        if [ -e "$source_path" ] && [ ! -L "$link_path" ]; then
            ln -s "$source_path" "$link_path"
            echo "  - Linked ~/$item" >&2
        fi
    done < "$CONFIG_FILE_PATH"
}

_symlink_artifacts() {
    local project_path="$1"
    local project_name="$2"
    local ephemeral_project_cache_dir="$EPHEMERAL_CACHE_DIR/$project_name"
    
    echo "Checking for heavy artifacts to symlink to ephemeral storage..." >&2

    # --- Smart Detection & Override Logic ---
    local auto_detected_dirs=()

    # --- Run Detectors ---
    if [ -d "$DETECTORS_DIR" ]; then
        for detector in "$DETECTORS_DIR"/*.sh; do
            if [ -f "$detector" ] && [ -x "$detector" ]; then
                detected=$(bash "$detector" "$project_path")
                auto_detected_dirs+=($detected)
            fi
        done
    fi

    local manual_dirs=()
    local override_file="$project_path/.workspace_symlinks"
    if [ -f "$override_file" ]; then
        echo "  - Found override file: .workspace_symlinks" >&2
        while IFS= read -r line; do [[ "$line" =~ ^\s*# ]] || [ -z "$line" ] && continue; manual_dirs+=("$line"); done < "$override_file"
    fi

    # --- Dynamic Discovery of Large, Untracked Dirs ---
    local candidate_dirs=()
    if [ -d "$project_path/.git" ]; then
        echo "  - Scanning for large, untracked directories..." >&2
        for dir in "$project_path"/*/; do
            dir_name=$(basename "$dir")
            if [[ " ${auto_detected_dirs[@]} " =~ " ${dir_name} " ]] || [[ " ${manual_dirs[@]} " =~ " ${dir_name} " ]] || [[ "$dir_name" == .* ]]; then continue; fi
            
            if ! git -C "$project_path" ls-files --error-unmatch "$dir_name" &>/dev/null; then
                dir_size_kb=$(du -sk "$dir" | cut -f1)
                if [ "$dir_size_kb" -gt "$LARGE_DIR_THRESHOLD_KB" ]; then
                    candidate_dirs+=("$dir_name")
                fi
            fi
        done
    fi

    if [ ${#candidate_dirs[@]} -gt 0 ]; then
        echo "  - Found large untracked directories: ${candidate_dirs[*]}" >&2
        read -p "    Move them to ephemeral storage? [y/N] " -n 1 -r
        echo >&2
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            manual_dirs+=("${candidate_dirs[@]}")
        fi
    fi

    local final_dirs_to_process=$(echo "${auto_detected_dirs[@]} ${manual_dirs[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' ')

    if [ -z "$final_dirs_to_process" ]; then echo "  - No artifact directories to process." >&2; return; fi

    # --- Symlinking Execution ---
    for dir_name in $final_dirs_to_process; do
        local project_artifact_path="$project_path/$dir_name"
        local cache_target_path="$ephemeral_project_cache_dir/$dir_name"
        
        mkdir -p "$cache_target_path"

        if [ -d "$project_artifact_path" ] && [ ! -L "$project_artifact_path" ]; then
            echo "  - Migrating '$dir_name' to ephemeral storage..." >&2
            if rsync -av "$project_artifact_path/" "$cache_target_path/"; then
                rm -rf "$project_artifact_path"
            else
                echo "    Error: rsync failed for '$dir_name'. Original directory left untouched." >&2
                continue
            fi
        fi
        
        if [ ! -d "$project_artifact_path" ]; then rm -f "$project_artifact_path"; fi
        if [ ! -e "$project_artifact_path" ]; then
            ln -s "$cache_target_path" "$project_artifact_path"
            echo "  - Symlinked '$dir_name' to ephemeral cache." >&2
        fi
    done
}

init_database() {
    if ! command -v sqlite3 &> /dev/null; then echo "Error: sqlite3 is not installed." >&2; exit 1; fi
    if [ ! -f "$DB_FILE" ]; then
        sqlite3 "$DB_FILE" "CREATE TABLE workspaces (path TEXT PRIMARY KEY, git_url TEXT, last_access INTEGER, frequency INTEGER DEFAULT 1);"
    fi
}

_update_history() {
    local git_url="$1"; local project_path="$2"; local current_time=$(date +%s)
    local existing_entry=$(sqlite3 "$DB_FILE" "SELECT path FROM workspaces WHERE path='$project_path';")
    if [ -z "$existing_entry" ]; then
        sqlite3 "$DB_FILE" "INSERT INTO workspaces (path, git_url, last_access, frequency) VALUES ('$project_path', '$git_url', $current_time, 1);"
    else
        sqlite3 "$DB_FILE" "UPDATE workspaces SET last_access=$current_time, frequency=frequency+1 WHERE path='$project_path';"
    fi
}

_handle_interactive_selection() {
    if [ ! -f "$DB_FILE" ]; then
        echo "No workspaces in history. Create one with 'workspace <git_repo_url_or_name>'." >&2
        exit 0
    fi

    local db_output
    db_output=$(sqlite3 -separator '|' "$DB_FILE" \
        "SELECT path, last_access FROM workspaces ORDER BY (frequency / (strftime('%s','now') - last_access + 1)) DESC, last_access DESC LIMIT 50;")

    if [ -z "$db_output" ]; then
        echo "No workspaces in history." >&2
        exit 0
    fi

    local project_path_to_enter=""

    if command -v fzf &>/dev/null; then
        # Use fzf for an enhanced interactive experience
        local fzf_input
        fzf_input=$(echo "$db_output" | while IFS='|' read -r path last_access; do
            local project_name=$(basename "$path")
            local status="[ ]"
            if [ -d "$path" ]; then status="[✓]"; fi
            printf "  %-5s %-40s %s\n" "$status" "$project_name" "$path"
        done)

        local selected_line
        selected_line=$(echo -e "$fzf_input" | fzf --height 40% --layout=reverse --info=inline --border --header='Select a workspace...' --ansi)
        project_path_to_enter=$(echo "$selected_line" | awk '{print $NF}')
    else
        # Fallback to a numbered list if fzf is not installed
        echo "Recent workspaces (ranked by frecency):" >&2
        local i=1
        local paths=()
        echo "$db_output" | while IFS='|' read -r path last_access; do
            local project_name=$(basename "$path")
            local status="[ ]"
            if [ -d "$path" ]; then status="[✓]"; fi
            printf "  %2d: %s %s\n" "$i" "$status" "$project_name" >&2
            paths[$i]="$path"
            i=$((i+1))
        done
        
        read -p "Enter a number to switch to a workspace, or any other key to cancel: " choice || true
        echo >&2
        
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ -n "${paths[$choice]}" ]; then
            project_path_to_enter="${paths[$choice]}"
        fi
    fi

    if [ -n "$project_path_to_enter" ]; then
        local project_name=$(basename "$project_path_to_enter")
        _symlink_artifacts "$project_path_to_enter" "$project_name"
        _link_configs "$project_path_to_enter"
        _update_history "" "$project_path_to_enter"
        echo "$project_path_to_enter"
    else
        echo "Cancelled." >&2
        exit 0
    fi
}

_handle_numeric_selection() {
    local choice="$1"
    if [ ! -f "$DB_FILE" ]; then exit 1; fi
    
    local path_to_enter
    path_to_enter=$(sqlite3 "$DB_FILE" "SELECT path FROM workspaces ORDER BY (frequency / (strftime('%s','now') - last_access + 1)) DESC, last_access DESC LIMIT 1 OFFSET (($choice - 1));")
    
    if [ -z "$path_to_enter" ]; then
        echo "Error: Invalid selection." >&2
        exit 1
    fi
    
    local project_name=$(basename "$path_to_enter")
    _symlink_artifacts "$path_to_enter" "$project_name"
    _link_configs "$path_to_enter"
    _update_history "" "$path_to_enter"
    echo "$path_to_enter"
}

_handle_project_creation_or_opening() {
    local INPUT="$1"
    local PROJECT_NAME
    local IS_GIT_REPO=false

    if [[ "$INPUT" == *git@* || "$INPUT" == *.git* || "$INPUT" == *http* ]]; then
        PROJECT_NAME=$(basename "$INPUT" .git)
        IS_GIT_REPO=true
    else
        PROJECT_NAME="$INPUT"
    fi

    local SANITIZED_NAME
    SANITIZED_NAME=$(echo "$PROJECT_NAME" | sed 's/[^a-zA-Z0-9_-]//g')
    if [ -z "$SANITIZED_NAME" ]; then
        echo "Error: Project name is invalid." >&2
        exit 1
    fi
    
    local PROJECT_PATH="$WORKSPACE_BASE_DIR/$SANITIZED_NAME"

    if [ "$IS_GIT_REPO" = true ] && [ -d "$PROJECT_PATH" ] && [ ! -d "$PROJECT_PATH/.git" ]; then
        echo "Warning: A non-Git workspace named '$SANITIZED_NAME' already exists." >&2
        read -p "Do you want to replace it by cloning '$INPUT'? [y/N] " -n 1 -r
        echo >&2
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            echo "  - Removing existing directory." >&2
            rm -rf "$PROJECT_PATH"
        else
            echo "  - Operation cancelled. Opening existing workspace." >&2
        fi
    fi

    if [ ! -d "$PROJECT_PATH" ]; then
        if [ "$IS_GIT_REPO" = true ]; then
            echo "Cloning '$INPUT' into '$PROJECT_PATH'..." >&2
            if ! git clone "$INPUT" "$PROJECT_PATH"; then
                echo "Error: Failed to clone." >&2
                exit 1
            fi
        else
            echo "Creating new empty workspace '$PROJECT_PATH'..." >&2
            mkdir -p "$PROJECT_PATH"
        fi
    else
        echo "Workspace '$SANITIZED_NAME' already exists." >&2
    fi

    _symlink_artifacts "$PROJECT_PATH" "$SANITIZED_NAME"
    _link_configs "$PROJECT_PATH"
    
    local GIT_URL="none"
    if [ -d "$PROJECT_PATH/.git" ]; then
        GIT_URL=$(git -C "$PROJECT_PATH" config --get remote.origin.url)
        if [[ "$GIT_URL" == https://github.com/* ]]; then
            local SSH_URL
            SSH_URL=$(echo "$GIT_URL" | sed 's|https://github.com/|git@github.com:|')
            echo "Converting clone URL to SSH for background warming: $SSH_URL" >&2
            GIT_URL="$SSH_URL"
        fi
    fi
    
    _update_history "$GIT_URL" "$PROJECT_PATH"
    echo "$PROJECT_PATH"
}

main() {
    case "$1" in
        --help|-h)
            show_help
            exit 0
            ;;
        warm)
            if [ -f "$WARM_SCRIPT_PATH" ]; then
                bash "$WARM_SCRIPT_PATH"
                echo "Workspace warming complete."
            else
                echo "Error: warm_workspaces.sh script not found." >&2
            fi
            exit 0
            ;;
        -*)
            echo "Error: Unknown option '$1'" >&2
            show_help >&2
            exit 1
            ;;
    esac

    init_database
    mkdir -p "$WORKSPACE_BASE_DIR"

    if [[ -z "$1" ]]; then
        local path_to_enter
        path_to_enter=$(_handle_interactive_selection)
        # This special echo is for the calling shell function to capture and cd
        echo "__cd__:$path_to_enter"
    elif [[ "$1" =~ ^[0-9]+$ ]]; then
        local path_to_enter
        path_to_enter=$(_handle_numeric_selection "$1")
        echo "__cd__:$path_to_enter"
    else
        local path_to_enter
        path_to_enter=$(_handle_project_creation_or_opening "$1")
        echo "__cd__:$path_to_enter"
    fi
}

main "$@"
