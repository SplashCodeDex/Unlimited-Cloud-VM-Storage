#!/bin/bash
# Enhanced script to create, list, and switch ephemeral workspaces.



# --- Configuration ---
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
SCRIPT_DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
source "$SCRIPT_DIR/config.sh"
source "$SCRIPT_DIR/visual_effects.sh" # Source the new visual effects script

# --- Derived Configurations ---
DETECTORS_DIR="$SCRIPT_DIR/detectors"
PROJECT_ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
CONFIG_FILE_PATH="$PROJECT_ROOT_DIR/$WORKSPACE_CONFIGS_FILE"
WARM_SCRIPT_PATH="$SCRIPT_DIR/warm_workspaces.sh"

# --- Helper Functions ---

show_help() {
    cat << EOF
Usage: workspace [OPTIONS] [COMMAND|PROJECT_NAME|GIT_URL]

A tool for creating, managing, and switching between ephemeral development workspaces.

OPTIONS:
  -o, --open    After switching to a workspace, prompt to open it in a configured editor.

COMMANDS:
  warm          Manually refresh all Git-based workspaces by fetching the latest changes.
  sync          Rescan the current directory for artifacts to symlink (use inside a workspace).
  doctor        Check for common problems and offer solutions.
  delete <name> Delete a workspace from your history and filesystem.
  --json        Output a JSON list of workspaces for machine consumption.
  --help        Show this help message.

MODES:
  Interactive:  workspace
                Shows a searchable menu of recent workspaces (requires fzf for the best experience).

  Direct:       workspace <n>
                Switch to the n-th most recent workspace.

                workspace <name>
                Create or switch to a local workspace named <name>.

                workspace <git_url>
                Clone a git repository and create a new workspace.
EOF
}

_link_configs() {
    local project_path="$1"
    if [ ! -d "$project_path" ]; then return; fi

    if [ ! -f "$CONFIG_FILE_PATH" ]; then
        print_warning "Configuration file not found at $CONFIG_FILE_PATH"
        return
    fi

    print_info "Linking configurations from $CONFIG_FILE_PATH..." >&2
    while IFS= read -r item || [[ -n "$item" ]]; do
        if [[ "$item" =~ ^\s*# ]] || [ -z "$item" ]; then continue; fi
        if [[ "$item" == ".bashrc" || "$item" == ".profile" || "$item" == ".zshrc" || "$item" == ".zprofile" ]]; then continue; fi

        local source_path="$HOME/$item"
        local link_path="$project_path/$(basename "$item")"
        if [ -e "$source_path" ] && [ ! -L "$link_path" ]; then
            ln -s "$source_path" "$link_path"
            print_info "  - Linked ~/$item" >&2
        fi
    done < "$CONFIG_FILE_PATH"
}

_symlink_artifacts() {
    if [ "$DISABLE_AUTO_SYMLINK" = true ]; then
        print_info "Automatic symlinking is disabled." >&2
        return
    fi

    local project_path="$1"
    local project_name="$2"
    local ephemeral_project_cache_dir="$EPHEMERAL_CACHE_DIR/$project_name"
    
    print_info "Checking for heavy artifacts to symlink to ephemeral storage..." >&2

    local auto_detected_dirs=()
    if [ -d "$DETECTORS_DIR" ]; then
        for detector in "$DETECTORS_DIR"/*.sh;
 do
            if [ -f "$detector" ] && [ -x "$detector" ]; then
                detected=$(bash "$detector" "$project_path")
                auto_detected_dirs+=($detected)
            fi
        done
    fi

    local manual_dirs=()
    local override_file="$project_path/.workspace_symlinks"
    if [ -f "$override_file" ]; then
        print_info "  - Found override file: .workspace_symlinks" >&2
        while IFS= read -r line; do [[ "$line" =~ ^\s*# ]] || [ -z "$line" ] && continue; manual_dirs+=("$line"); done < "$override_file"
    fi

    local candidate_dirs=()
    if [ -d "$project_path/.git" ]; then
        print_info "  - Scanning for large, untracked directories..." >&2
        for dir in "$project_path"/*/;
 do
            dir_name=$(basename "$dir")
            if [[ " ${auto_detected_dirs[@]} " =~ " ${dir_name} " ]] || [[ " ${manual_dirs[@]} " =~ " ${dir_name} " ]] || [[ "$dir_name" == .* ]]; then continue; fi
            
            if ! git -C "$project_path" ls-files --error-unmatch "$dir_name" &>/dev/null;
 then
                dir_size_kb=$(du -sk "$dir" | cut -f1)
                if [ "$dir_size_kb" -gt "$LARGE_DIR_THRESHOLD_KB" ]; then
                    candidate_dirs+=("$dir_name")
                fi
            fi
        done
    fi

    if [ ${#candidate_dirs[@]} -gt 0 ]; then
        print_warning "Found large untracked directories: ${candidate_dirs[*]}" >&2
        print_warning "Moving them to ephemeral storage can save space, but it might break build scripts." >&2
        echo -n "    Move them to ephemeral storage? [y/N] " >&2
        read -r
        echo >&2
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            manual_dirs+=("${candidate_dirs[@]}")
        fi
    fi

    local final_dirs_to_process=$(echo "${auto_detected_dirs[@]} ${manual_dirs[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' ')

    if [ -z "$final_dirs_to_process" ]; then print_info "  - No artifact directories to process." >&2; return; fi

    for dir_name in $final_dirs_to_process;
 do
        local project_artifact_path="$project_path/$dir_name"
        local cache_target_path="$ephemeral_project_cache_dir/$dir_name"
        
        mkdir -p "$cache_target_path"

        if [ -d "$project_artifact_path" ] && [ ! -L "$project_artifact_path" ]; then
            print_info "  - Migrating '$dir_name' to ephemeral storage..." >&2
            rsync -av "$project_artifact_path/" "$cache_target_path/" & 
            local rsync_pid=$!
            spinner $rsync_pid "Migrating '$dir_name' to ephemeral storage..." 
            wait $rsync_pid
            if [ $? -eq 0 ]; then
                rm -rf "$project_artifact_path"
                print_success "  - Migration complete." >&2
            else
                print_error "    Error: rsync failed for '$dir_name'. Original directory left untouched."
                continue
            fi
        fi
        
        if [ ! -d "$project_artifact_path" ]; then rm -f "$project_artifact_path"; fi
        if [ ! -e "$project_artifact_path" ]; then
            ln -s "$cache_target_path" "$project_artifact_path"
            print_info "  - Symlinked '$dir_name' to ephemeral cache." >&2
        fi
    done
}

init_database() {
    if ! command -v sqlite3 &> /dev/null; then print_error "sqlite3 is not installed."; exit 1; fi
    if [ -f "$DB_FILE" ]; then
        if ! sqlite3 "$DB_FILE" ".tables" &> /dev/null;
 then
            print_warning "The workspace database appears to be corrupted."
            echo -n "Do you want to recreate it? (This will delete your workspace history) [y/N] "
            read -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                rm -f "$DB_FILE"
                print_info "Database recreated."
            else
                print_error "Database is corrupted. Please fix it manually or delete it."
                exit 1
            fi
        fi
    fi
    if [ ! -f "$DB_FILE" ]; then
        sqlite3 "$DB_FILE" "CREATE TABLE workspaces (path TEXT PRIMARY KEY, git_url TEXT, last_access INTEGER, frequency INTEGER DEFAULT 1);"
    fi
}

_update_history() {
    local git_url="$1"; local project_path="$2"; local current_time=$(date +%s)
    local existing_entry=$(sqlite3 "$DB_FILE" "SELECT path FROM workspaces WHERE path='$project_path';")
    if [ -z "$existing_entry" ]; then
        sqlite3 "$DB_FILE" "INSERT INTO workspaces (path, git_url, last_access, frequency) VALUES ('$project_path', '$git_url', $current_time, 1);"
    else
        sqlite3 "$DB_FILE" "UPDATE workspaces SET last_access=$current_time, frequency=frequency+1 WHERE path='$project_path';"
    fi
}

_get_path_by_name() {
    local project_name_to_find="$1"
    # This is inefficient, but safer than a simple LIKE in sql
    local db_output=$(sqlite3 -separator '|' "$DB_FILE" "SELECT path FROM workspaces;")
    echo "$db_output" | while IFS='|' read -r path;
 do
        if [ "$(basename "$path")" = "$project_name_to_find" ]; then
            echo "$path"
            return
        fi
    done
}

_get_project_icon() {
    local path="$1"
    if [ -f "$path/package.json" ]; then
        echo "" # Node.js icon
    elif [ -f "$path/requirements.txt" ]; then
        echo "" # Python icon
    elif [ -f "$path/go.mod" ]; then
        echo "Go" # Go icon
    elif [ -d "$path/.git" ]; then
        echo "" # Git icon
    else
        echo "" # Folder icon
    fi
}

_get_git_status() {
    local path="$1"
    if [ ! -d "$path/.git" ]; then echo ""; return; fi

    local branch=$(git -C "$path" rev-parse --abbrev-ref HEAD 2>/dev/null)
    local last_commit_date=$(git -C "$path" log -1 --format=%cr 2>/dev/null)
    local status
    local color

    if ! git -C "$path" diff-index --quiet HEAD --;
 then
        status="[!M]"
        color="$COLOR_YELLOW"
    else
        # Check if behind remote
        if ! git -C "$path" fetch --quiet 2>/dev/null;
 then
            status="[E]"
            color="$COLOR_RED"
        elif [ $(git -C "$path" rev-list HEAD...@{u} --count) -gt 0 ]; then
            status="[↓]"
            color="$COLOR_RED"
        else
            status="[✓]"
            color="$COLOR_GREEN"
        fi
    fi

    echo -e "${color}${status}${COLOR_RESET} ($branch) - ${last_commit_date}"
}

_get_git_status_json() {
    local path="$1"
    if [ ! -d "$path/.git" ]; then echo "non-git|||"; return; fi

    local branch=$(git -C "$path" rev-parse --abbrev-ref HEAD 2>/dev/null)
    local last_commit_date=$(git -C "$path" log -1 --format=%cr 2>/dev/null)
    local status

    if ! git -C "$path" diff-index --quiet HEAD --;
 then
        status="modified"
    else
        git -C "$path" fetch --quiet
        if [ $(git -C "$path" rev-list HEAD...@{u} --count) -gt 0 ]; then
            status="behind"
        else
            status="clean"
        fi
    fi
    echo "$status|$branch|$last_commit_date"
}


_handle_interactive_selection() {
    if [ ! -f "$DB_FILE" ]; then
        print_info "No workspaces in history. Create one with 'workspace <git_repo_url_or_name>'."
        exit 0
    fi

    local db_output
    db_output=$(sqlite3 -separator '|' "$DB_FILE" 
        "SELECT path, last_access FROM workspaces ORDER BY (frequency * (1.0 / (strftime('%s','now') - last_access + 1))) DESC, last_access DESC LIMIT 50;")

    if [ -z "$db_output" ]; then
        print_info "No workspaces in history."
        exit 0
    fi

    local project_path_to_enter=""

    if command -v fzf &>/dev/null;
 then
        local fzf_input
        fzf_input=$(echo "$db_output" | while IFS='|' read -r path last_access;
 do
            local project_name=$(basename "$path")
            local project_icon=$(_get_project_icon "$path")
            local git_status=$(_get_git_status "$path")
            printf "%s %-40s %s %s\n" "$project_icon" "$project_name" "$git_status" "$path"
        done)

        local selected_line
        selected_line=$(echo -e "$fzf_input" | fzf --height 40% --layout=reverse --info=inline --border --header='Select a workspace...' --ansi)
        project_path_to_enter=$(echo "$selected_line" | awk '{print $NF}')
    else
        print_info "Recent workspaces (ranked by frecency):"
        local i=1
        local paths=()
        echo "$db_output" | while IFS='|' read -r path last_access;
 do
            local project_name=$(basename "$path")
            local project_icon=$(_get_project_icon "$path")
            local git_status=$(_get_git_status "$path")
            print_info "  $i: $project_icon $project_name $git_status"
            paths[$i]="$path"
            i=$((i+1))
        done
        
        echo -n "Enter a number to switch to a workspace, or any other key to cancel: "
        read -r choice
        echo >&2
        
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ -n "${paths[$choice]}" ]; then
            project_path_to_enter="${paths[$choice]}"
        fi
    fi

    if [ -n "$project_path_to_enter" ]; then
        local project_name=$(basename "$project_path_to_enter")
        _symlink_artifacts "$project_path_to_enter" "$project_name"
        _link_configs "$project_path_to_enter"
        _update_history "" "$project_path_to_enter"
        echo "$project_path_to_enter"
    else
        print_warning "Cancelled."
        exit 0
    fi
}

_handle_json_output() {
    if [ ! -f "$DB_FILE" ]; then echo "[]"; exit 0; fi

    local db_output
    db_output=$(sqlite3 -separator '|' "$DB_FILE" 
        "SELECT path, git_url, last_access FROM workspaces ORDER BY (frequency * (1.0 / (strftime('%s','now') - last_access + 1))) DESC, last_access DESC LIMIT 50;")

    if [ -z "$db_output" ]; then echo "[]"; exit 0; fi

    if command -v jq &>/dev/null;
 then
        echo "$db_output" | while IFS='|' read -r path git_url last_access;
 do
            local project_name=$(basename "$path")
            local git_status_str=$(_get_git_status_json "$path")
            local status=$(echo "$git_status_str" | cut -d'|' -f1)
            local branch=$(echo "$git_status_str" | cut -d'|' -f2)
            local last_commit_date=$(echo "$git_status_str" | cut -d'|' -f3)

            jq -n --arg name "$project_name" --arg path "$path" --arg git_url "$git_url" \
                  --arg branch "$branch" --arg status "$status" --arg last_commit "$last_commit_date" \
                  --arg last_access "$last_access" \
                  '{name: $name, path: $path, git_url: $git_url, branch: $branch, status: $status, last_commit: $last_commit, last_access: $last_access}'
        done | jq -s '.'
    else
        echo "["
        first=true
        echo "$db_output" | while IFS='|' read -r path git_url last_access;
 do
            if [ "$first" = true ]; then first=false; else echo ","; fi
            local project_name=$(basename "$path")
            local git_status_str=$(_get_git_status_json "$path")
            local status=$(echo "$git_status_str" | cut -d'|' -f1)
            local branch=$(echo "$git_status_str" | cut -d'|' -f2)
            local last_commit_date=$(echo "$git_status_str" | cut -d'|' -f3)
            
            printf '{"name": "%s", "path": "%s", "git_url": "%s", "branch": "%s", "status": "%s", "last_commit": "%s", "last_access": "%s"}' \
                "$project_name" "$path" "$git_url" "$branch" "$status" "$last_commit_date" "$last_access"
        done
        echo "]"
    fi
}

_handle_numeric_selection() {
    local choice="$1"
    if [ ! -f "$DB_FILE" ]; then exit 1; fi
    
    local path_to_enter
    path_to_enter=$(sqlite3 "$DB_FILE" "SELECT path FROM workspaces ORDER BY (frequency * (1.0 / (strftime('%s','now') - last_access + 1))) DESC, last_access DESC LIMIT 1 OFFSET (($choice - 1));")
    
    if [ -z "$path_to_enter" ]; then
        print_error "Invalid selection."
        exit 1
    fi
    
    local project_name=$(basename "$path_to_enter")
    _symlink_artifacts "$path_to_enter" "$project_name"
    _link_configs "$path_to_enter"
    _update_history "" "$path_to_enter"
    echo "$path_to_enter"
}

_handle_project_creation_or_opening() {
    local INPUT="$1"
    local PROJECT_NAME
    local IS_GIT_REPO=false

    if [[ "$INPUT" == *git@* || "$INPUT" == *.git* || "$INPUT" == *http* ]]; then
        PROJECT_NAME=$(basename "$INPUT" .git)
        IS_GIT_REPO=true
    else
        PROJECT_NAME="$INPUT"
    fi

    local SANITIZED_NAME=$(echo "$PROJECT_NAME" | sed -e 's|https://github.com/||' -e 's|/| |g' | awk '{print $NF}' | sed 's/\.git//')
    local PROJECT_PATH="$WORKSPACE_BASE_DIR/$SANITIZED_NAME"

    if [ ! -d "$PROJECT_PATH" ] && command -v autojump &>/dev/null;
 then
        local autojump_path=$(autojump -s "$SANITIZED_NAME")
        if [ -n "$autojump_path" ] && [ -d "$autojump_path" ]; then
            print_info "Found matching directory with autojump: $autojump_path" >&2
            echo -n "Do you want to treat this as a workspace? [Y/n] " >&2
            read -r
            echo >&2
            if [[ ! $REPLY =~ ^[Nn]$ ]]; then
                PROJECT_PATH="$autojump_path"
                SANITIZED_NAME=$(basename "$autojump_path")
            fi
        fi
    fi

    if [ "$IS_GIT_REPO" = true ] && [ -d "$PROJECT_PATH" ] && [ ! -d "$PROJECT_PATH/.git" ]; then
        print_warning "A non-Git workspace named '$SANITIZED_NAME' already exists." >&2
        echo -n "Do you want to replace it by cloning '$INPUT'? [y/N] " >&2
        read -r
        echo >&2
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            rm -rf "$PROJECT_PATH"
        else
            print_info "Operation cancelled. Opening existing workspace." >&2
        fi
    fi

    if [ ! -d "$PROJECT_PATH" ]; then
        if [ "$IS_GIT_REPO" = true ]; then
            print_info "Cloning '$INPUT' into '$PROJECT_PATH'..." >&2
            git clone "$INPUT" "$PROJECT_PATH" & 
            local git_pid=$!
            spinner $git_pid "Cloning '$INPUT' into '$PROJECT_PATH'..." 
            wait $git_pid
            if [ $? -ne 0 ]; then
                print_error "Cloning failed. Please check the URL and your network connection."
                rm -rf "$PROJECT_PATH" # Clean up failed clone
                exit 1 # Exit with an error
            fi
            print_success "Cloning complete." >&2
        else
            print_info "Creating new empty workspace '$PROJECT_PATH'..." >&2
            mkdir -p "$PROJECT_PATH"
        fi
    else
        print_info "Workspace '$SANITIZED_NAME' already exists." >&2
    fi

    _symlink_artifacts "$PROJECT_PATH" "$SANITIZED_NAME"
    _link_configs "$PROJECT_PATH"
    
    local GIT_URL="none"
    if [ -d "$PROJECT_PATH/.git" ]; then
        GIT_URL=$(git -C "$PROJECT_PATH" config --get remote.origin.url)
        if [[ "$GIT_URL" == https://github.com/* ]]; then
            GIT_URL=$(echo "$GIT_URL" | sed 's|https://github.com/|git@github.com:|')
            print_info "Converting clone URL to SSH for background warming: $GIT_URL" >&2
        fi
    fi
    
    _update_history "$GIT_URL" "$PROJECT_PATH"
    echo "$PROJECT_PATH"
}

doctor() {
    print_info "${TEXT_BOLD}Running workspace doctor...${TEXT_RESET}"
    local all_ok=true

    printf "1. Checking core dependencies: "
    if ! command -v git &>/dev/null || ! command -v sqlite3 &>/dev/null || ! command -v rsync &>/dev/null;
 then
        print_error "FAIL (git, sqlite3, or rsync is missing)" ; all_ok=false
    else
        print_success "OK"
    fi

    printf "2. Checking for tput: "
    if ! command -v tput &>/dev/null;
 then
        print_warning "WARNING (tput is not installed, text formatting will be disabled)"
    else
        print_success "OK"
    fi

    printf "3. Checking for jq (optional but recommended for VS Code extension): "
    if ! command -v jq &>/dev/null;
 then
        print_warning "WARNING (jq is not installed)"
    else
        print_success "OK"
    fi

    printf "4. Checking shell integration: "
    local shell_name=$(basename "$SHELL")
    local profile_to_update=""
    if [ "$shell_name" = "bash" ]; then profile_to_update="$HOME/.bashrc"; fi
    if [ "$shell_name" = "zsh" ]; then profile_to_update="$HOME/.zshrc"; fi

    if [ -z "$profile_to_update" ]; then
        print_warning "WARNING (Unsupported shell '$shell_name', manual check required)"
    elif ! grep -q "# >>> workspace tool initialize >>>" "$profile_to_update"; then
        print_error "FAIL ($profile_to_update is not correctly configured)" ; all_ok=false
    else
        print_success "OK"
    fi

    printf "5. Checking database file: "
    if [ ! -f "$DB_FILE" ]; then
        print_warning "WARNING (Database not found, will be created on next run)"
    else
        print_success "OK"
    fi

    printf "6. Checking workspace directory: "
    if [ ! -d "$WORKSPACE_BASE_DIR" ]; then
        print_warning "WARNING (Base directory '$WORKSPACE_BASE_DIR' not found)"
    else
        print_success "OK"
    fi

    if [ "$all_ok" = true ]; then
        print_success "\nAll checks passed! Your workspace environment appears to be healthy."
    else
        print_error "\nDoctor found some issues. Please review the output above."
    fi
}

main() {
    case "$1" in
        --help|-h) show_help; exit 0 ;; 
        sync) 
            print_info "Syncing workspace..." >&2
            _symlink_artifacts "$(pwd)" "$(basename "$(pwd)")"
            print_success "Workspace sync complete." >&2
            exit 0 ;; 
        warm) 
            print_info "Warming workspaces..." >&2
            bash "$WARM_SCRIPT_PATH" & 
            spinner $! "Warming workspaces..." 
            print_success "Workspace warming complete." >&2
            exit 0 ;; 
        doctor) doctor; exit 0 ;; 
        delete)
            local name_to_delete="$2"
            if [ -z "$name_to_delete" ]; then
                print_error "Please provide a workspace name to delete." >&2
                exit 1
            fi
            
            local path_to_delete=$(_get_path_by_name "$name_to_delete")

            if [ -z "$path_to_delete" ] || [ ! -d "$path_to_delete" ]; then
                print_error "Workspace '$name_to_delete' not found." >&2
                exit 1
            fi

            rm -rf "$path_to_delete"
            sqlite3 "$DB_FILE" "DELETE FROM workspaces WHERE path='$path_to_delete';"
            print_success "Workspace deleted: $path_to_delete"
            exit 0 ;; 
        --get-base-dir) echo "$WORKSPACE_BASE_DIR"; exit 0 ;; 
        --json) _handle_json_output; exit 0 ;; 
        -*)
            print_error "Unknown option '$1'"
            show_help >&2
            exit 1
            ;; 
    esac

    init_database
    mkdir -p "$WORKSPACE_BASE_DIR"

    if [[ -z "$1" ]]; then
        local path_to_enter=$(_handle_interactive_selection)
        echo "__cd__:$path_to_enter"
    elif [[ "$1" =~ ^[0-9]+$ ]]; then
        local path_to_enter=$(_handle_numeric_selection "$1")
        echo "__cd__:$path_to_enter"
    else
        local path_to_enter=$(_handle_project_creation_or_opening "$1")
        echo "__cd__:$path_to_enter"
    fi
}

main "$@"